<html>
  <head>
    <title>JPT: User's Guide</title>
    <style>
      body { 
        background-color: white; 
        font-size: 12pt; 
        color: black; 
        font-family: arial,helvetica,verdana; 
      }
      h1 { font-size: 24pt; font-weight: bold; }
      h2 { font-size: 20pt; font-weight: bold; }
      h3 { font-size: 18pt; font-weight: bold; }
      h4 { font-size: 16pt; font-weight: bold; }
      .sub { font-size: 10pt; }
      code { color: red; }
      pre { background-color: black; color: white; padding-top: 1em; padding-left: 4em;}
    </style>
  </head>
  <body>
    <a name="top"></a>
    <h1>JPT: User's Guide</h1>
    <div class="sub">last modified: 2015/22/04</div>
    <div class="sub">author <a href="mailto:chris@christophermrossi.com">Chris Rossi</a></div>
    <div class="sub">contributed by <a href="mailto:david.javapagetemplates@gmail.com">David Cana</a></div>

    <a name="zpt"></a>
    <h2>Zope Page Templates</h2>
    <p>
      JPT is a Java implementation of Zope Page Templates (ZPT). Because JPT
      isn't running in the context of Zope and isn't written with Python,
      there are necessarily some differences between JPT and ZPT. This document
      will concentrate on the ways that JPT differs from ZPT. For an introduction
      to ZPT refer to the chapter 
      <a href="http://docs.zope.org/zope2/zope2book/ZPT.html">Using
      Zope Page Templates</a> in the 
      <a href="http://docs.zope.org/zope2/zope2book/">Zope Book</a>.
      For a complete reference to ZPT, refer to the 
      <a href="http://docs.zope.org/zope2/zope2book/AppendixC.html">ZPT Reference</a>.
    </p>
    
    <a name="zpt.maven"></a>
    <h3>Maven project</h3>
    <p>
      JPT uses <a href="https://maven.apache.org/">Maven</a> as build automation tool. If you know
      how a Maven project works you can skip this chapter.
    </p>
    <p>
      If you want to test JPT the next command lines are useful:
      <pre>
mvn clean            // Clean the files and directories generated by Maven during its build
mvn javadoc:javadoc  // Generates documentation for the Java code using the standard Javadoc Tool
mvn test             // Run the entire unit tests
mvn assembly:single  // Assemble an application bundle
      </pre>
    </p>
    <p>
      If you want to add JPT to any java project:
      <pre>
mvn install          // Install the project in the local repository
      </pre>
      Add to your POM file of any project you want JPT to work the next dependency :
      <pre>
&lt;dependency&gt;
  &lt;groupId&gt;org.javapagetemplates&lt;/groupId&gt;
  &lt;artifactId&gt;jpt&lt;/artifactId&gt;
  &lt;version&gt;0.12.0&lt;/version&gt;
&lt;/dependency&gt;
      </pre>
    </p>
    <p>
      For eclipse integration:
      <pre>
mvn eclipse:clean    // Deletes the .project, .classpath, .wtpmodules files and .settings folder used by Eclipse
mvn -Declipse.workspace=/home/user/workspace eclipse:eclipse  // Generates needed eclipse configuration files
      </pre>
    </p>
    
    
    <a name="zpt.evaluationOrder"></a>
    <h3>Evaluation order</h3>
    <p>
      The order evaluation of attributes in JPT is not equal than ZPT's. The new order is:
      <ul>
        <li><code>tal:repeat</code></li>
        <li><code>tal:on-error</code> / <code>i18n:on-error</code></li>
        <li><code>tal:define</code></li>
        <li><code>i18n:domain</code></li>
        <li><code>i18n:define</code></li>
        <li><code>tal:condition</code></li>        
        <li><code>tal:content</code> / <code>i18n:content</code></li>
        <li><code>tal:attributes</code> / <code>i18n:attributes</code></li>
        <li><code>tal:omit-tag</code></li>
        <li><code>tal:tag</code></li>
        <li>content</li>
      </ul>
    </p>


    <a name="tales"></a>
    <h2>TALES Expression Syntax</h2>
    <p>
      There are some fundamental differences between path expressions in ZPT and
      JPT. Generally speaking, path expressions are resolved in JPT by traversing,
      by means of reflection, properties and methods of Java objects. 
    </p>

    <a name="tales.path"></a>
    <h3>Path Expressions</h3>
    <p>
      The first element in a path expression must be a variable, a class, or a literal.
    </p>

    <a name="tales.path.literals"></a>
    <h4>Literals</h4>
    <p>
      Numeric and boolean literals are defined in the same way as in the Java language.  
      String literals are delimited by single quotes.  Some example literals:
      <ul>
        <li><code>9</code> (integer literal)</li>
        <li><code>9.0</code> (floating point literal)</li>
        <li><code>32l</code> (long integer literal)</li>
        <li><code>true</code> (boolean literal)</li>
        <li><code>'foobar'</code> (string literal)</li>
      </ul>
    </p>

    <a name="tales.variables"></a>
    <h4>Variables</h4>
    <p>
      A variable is either predefined, defined
      via a <code>tal:define</code> attribute, or passed in to the template at runtime.  
      The following variables are predefined:
      <ul>
        <li><code>here</code> refers to the context object, passed in at runtime</li>
        <li><code>template</code> refers to the template object</li>
        <li><code>resolver</code> refers to an instance of <code>Resolver</code> and is
            used to find resources, such as other templates.  see <code><a href="#metal">metal:use-macro</a></code></li>
        <li><code>repeat</code> see <code><a href="#tal.repeat">tal:repeat</a></code></li>
        <li><code>date</code> an instance of a <code><a href="#tales.helpers.date">date helper</a></code></li>
        <li><code>shell</code> refers to an instance of <code>EvaluationHelper</code>.</li>
      </ul>
      The scope of the variables defined via a <code>tal:define</code> attribute is local. An example:
      <pre>
&lt;div tal:define="a here/number"&gt;
    &lt;span tal:replace="a">5&lt;/span&gt;
&lt;/div&gt;
&lt;span tal:replace="a">null&lt;/span&gt;
      </pre>
      At the first replace the value in <code>here/number</code> will be used. At the second replace, a <code>null</code> value (the <code>a</code> variable is out of scope).<br />
      
      The following variables are defined in ZPT but not in JPT:
      <code>options, CONTEXTS, root, container, request, user, modules</code>.  
      The following variables are defined in ZPT but aren't yet implemented in JPT:
      <code>nothing, default, attrs</code>.  If you need these, holler.
    </p>

    <a name="tales.path.classes"></a>
    <h4>Classes</h4>
    <p>
      A class may be referred to by it's fully qualified name.  This can allow calling
      static methods on the class.  Example:
      <ul>
        <li><code>java.lang.System.currentTimeMillis()</code></li>
      </ul>
      A fully qualifed class name followed by <code>.class</code> allows you to
      refer to the class object itself. Example:
      <ul>
        <li><code>java.lang.Integer.class/instanceof( here/number )</code></li>
      </ul>
    </p>

    <a name="tales.path.traversal"></a>
    <h4>Path traversal</h4>
    <p>
      Following the initial path element, path elements are either properties or methods
      of the preceding object. Properties are denoted as a simple name and are resolved
      as Java Bean properties. Example:
      <ul>
        <li><code>here/name</code> will search for a method <code>getName()</code>
            in the passed context object.
        </li>
      </ul> 
      Alternatively, if a parent object is a <code>Map</code> it will be treated as
      a dictionary and the processor will attempt a lookup with the next path element
      as key.  
      <ul>
        <li><code>here/people/suzanne</code> if <code>people</code> is an instance
        of <code>Map</code>, expression will be equivalent to the Java code:
        <code>people.get( "suzanne" )</code></li>
      </ul>
    </p>
    <p>
      An arbitrary method may be called by specifying
      the method name followed by an argument list contained in parentheses. In the 
      preceding example, '<code>here/name</code>' is equivalent to '<code>here/getName()</code>'. Arguments in
      method calls are evaluated as expressions.
      <ul>
        <li><code>here/doSomething( 9, 8 )</code></li>
        <li><code>here/values()/size()</code></li>
        <li><code>here/getPage( request/getParameter('page') )</code></li>
      </ul>
      Properties and methods must be publically accessible. The last element in a path 
      expression may resolve to <code>null</code>, but if an intermediate element resolves
      to <code>null</code> a <code>NoSuchPathException</code> will be thrown. 
    </p>
    
    <a name="tales.path.arrays"></a>
    <h4>Arrays</h4>
    <p>
      Array members may be accessed using the same syntax as in Java. Any number of 
      dimensions are supported. The expression inside the array accessor may be any
      TALES expression and must evaluate to an integer value. If an array accessor
      is found modifying an object that is not an array an exception is thrown.
      <ul>
        <li><code>here/people[ 2 ]</code></li>
        <li><code>here/grid[ point / x ][ point / y ]</code></li>
      </ul>
    </p>
      
    <a name="tales.helpers">
    <h3>Helper Objects</h3>
    <p>
      In ZPT, when expressions start to get complicated, you can resort to using
      python expressions. Although, truly complicated logic should be encapsulated
      in methods in external objects, sometimes you just want write a simple 
      boolean expression or add two numbers. JPT includes some helper objects,
      (<code>date</code>) and expressions which are available to the template as variables.
    </p>
    
    <p>
      Helper objects were added to JPT before the author
      discovered <a href="http://www.beanshell.org">BeanShell</a> and 
      integrated it into JPT.  This allows JPT the use of 
      <a href="#tales.java">Java expressions</a> just
      like the use of Python expressions in ZPT. Anyway, using JPT expressions and helpers the need of using java expressions
      reduces very much.
    </p>

    <a name="tales.helpers.date">
    <h4>DateHelper</h4>
    <p>
      The built-in variable <code>date</code> is a helper object with the following
      static method:
      <ul>
        <li><code>format( <i>formatString</i>, <i>date</i> )</code> format date according to format string</li>
      </ul>
      The format string follows the same rules used by 
      <a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a>.
      An example:
      <ul>
        <li><code>date/format( 'EEE MMMM d, yyyy h:mm:ss a', here/birthday )</code></li>
      </ul>
    </p>
    
    <a name="tales.java"></a>
    <h3>Java expressions</h3>
    <p>
      Java expressions are made possible in JPT by <a href="http://www.beanshell.org">BeanShell</a>,
      a scripting language that is fully compatible with the Java programming language and adds
      some features of its own. For the complete rundown and what you can do with BeanShell,
      you should visit their <a href="http://www.beanshell.org">website</a>.  The interpreter
      is very light weight and makes some very cool things possible.
    </p>
    <p>
      Java expressions work just like Python expressions in ZPT except that the Java language
      is used instead of Python. Any legal Java (or BeanShell) expression may be evaluated.
      Some examples:
      <ul>
        <li><code>bsh: 4 + 5</code> returns the int 9</li>
        <li><code>bsh: random = new Random( System.currentTimeMillis() ); 1 + random.nextInt( 10 )</code>
            generates a random number between 1 and 10.</li>
      </ul>
    </p>
    <p>
      We can also use Groovy instead of BeanShell:
      <ul>
        <li><code>groovy: 4 + 5</code> returns the int 9.</li>
        <li><code>groovy: true ? ( false ? sRock : sTree ) : sPrimate</code> returns the value of sTree.</li>
      </ul>
    </p>
    <p>
      We can also use another kind of expression:
      <ul>
        <li><code>java: 4 + 5</code> returns the int 9.</li>
        <li><code>java: random = new Random( System.currentTimeMillis() ); 1 + random.nextInt( 10 )</code>
            generates a random number between 1 and 10.</li>
      </ul>
    </p>
    <p>
      The default evaluator for <code>java:</code> expressions is BeanShell.
      JPT also makes it easy to define any other scripting language as the default. It declares 3 very simple
      interfaces (<code>EvaluationHelper</code>, <code>Evaluator</code> y <code>Script</code>) that must be 
      implemented to use a scripting language. JPT includes 2 implementations: for 
      <a href="http://www.beanshell.org">BeanShell</a> and for <a href="http://www.groovy-lang.org">Groovy</a>.
      Additional implementations can be added.
      Use the <code>void setExpressionEvaluator( Evaluator expressionEvaluator )</code> of the <code>JPTContext</code> 
      class for customizing the evaluator for java labeled expressions; to set Groovy use:
      <pre>
JPTContext.getInstance().setExpressionEvaluator( 
                    GroovyEvaluator.getInstance() );
      </pre>
    </p>
    <p>
      What happens when you want to use ampersands in a java expression? You must escape them because a Java Page Template
      must be a well formed XML document. An example:
      <ul>
        <li><code>java: condition1 &amp;amp;&amp;amp; condition2</code>. True only if both conditions are true</li>
      </ul>
      That code is awfull. JPT provides an alternative method to escape ampersands. Replacing ampersands with another char;
      the default is '_'. The previous expression transforms into:
      <ul>
        <li><code>java: condition1 __ condition2</code>. True only if both conditions are true</li>
      </ul>
      If you prefer to use the '~' char use this:
      <pre>
JPTContext.getInstance().setCharToReplaceAmpersand( '~' );
      </pre>
    </p>
    
    <a name="tales.java.scripts"></a>
    <h4>Scripts</h4>
    <p>
      Snippets of code that are longer than a line or two can be stored externally
      in a script that is callable by JPT. Scripts are accessed using the <code>resolver</code>
      variable just like with <a href="#metal">macros</a>. The 
      <code>Resolver.getScript( String uri )</code> method returns a Script
      object that is evaluated by executing the code.  The return value, if not specified by
      a <code>return</code> statement is that last expression in the script.  
      Example:<br/>
      <pre>
&lt;div tal:content="resolver/getScript( 'coolscript.bsh' )"&gt;
  The output of my very cool BeanShell script.
&lt;/div&gt;
      </pre>
    </p>
    <p>
      The kind of script depends on the extension of the file. By default file names ended by <code>'.bsh'</code>
      are interpreted by BeanShell and file names ended by <code>'.groovy'</code> by Groovy. JPT allows to customize 
      this settings and to add support from more script types and file extensions. See 
      <a href="#tales.context">JPT context section</a> for details.
    </p>
      
    <a name="tales.java.variables"></a>
    <h4>Variables</h4>
    <p>
      Variables are shared between the page template and the shell context. So all of
      the variables already defined for the template are available in Java expressions or
      scripts. And by the same token, any new variable defined in a script or Java expression 
      can be accessed from a path expression.
    </p>
    
    <a name="tales.exists"></a>
    <h3>Exists expressions</h3>
    <p>
      Exists epxressions work more or less like in ZPT. If an expression evaluates to
      <code>null</code> or causes a NoSuchPathException to be thrown, the expression
      evaluates to <code>false</code>. Otherwise the expression evaluates to <code>true</code>.
    </p>

    <a name="tales.not"></a>
    <h3>Not expressions</h3>
    <p>
      Not expressions work more or less like in ZPT. The expression to which <code>not:</code>
      is applied must first be cast to a boolean. The result is then negated. Casts to 
      boolean follow these rules:
      <ul>
        <li>For numbers, <code>0</code> evaluates to <code>false</code>; any non-zero number evaluates to 
            <code>true</code>.</li>
        <li>Empty collections or maps evaluate to <code>false</code>; those containing any
            non-zero number of elements evaluate to <code>true</code></li>
        <li><code>null</code> evaluates to <code>false</code>. Any non-null object evaluates
            to <code>true</code>, unless that object is an instance of <code>Boolean</code>,
            <code>Number</code>, <code>Collection</code>, or <code>Map</code>, in which case
            it evaluates according to the rules above.</li>
      </ul>
    </p>
    
    <a name="tales.math">
    <h3>Math expressions</h3>
    <p>
      You can do some math operations using this expressions:
      <ul>
        <li><code>+: x y</code> -> add x and y</li>
        <li><code>-: x y</code> -> subtract y from x</li>
        <li><code>*: x y</code> -> multiply x and y</li>
        <li><code>:: x y</code> -> divide x by y</li>
        <li><code>%: x y</code> -> x mod y</li>
      </ul>
      In all cases, <i>x</i> and <i>y</i> are assumed integers. You can use more than 2 values to operate. 
      You can use parenthesis. Some examples:
      <ul>
        <li><code>-: here/assets here/liabilities</code></li>
        <li><code>*: 2 here/children</code></li>
        <li><code>+: 1 here/number1 here/number2</code></li>
        <li><code>+: 1 ( *: here/number1 here/number2 )</code></li>
      </ul>
    </p>
    
    
    <a name="tales.bool">
    <h3>Boolean expressions</h3>
    <p>
      The built-in variable <code>bool</code> is a helper object with the following 
      static methods:
      <ul>
        <li><code>or: x y</code> -> boolean or of expressions x and y</li>
        <li><code>and: x y</code> -> boolean and of expressions x and y</li>
        <li><code>cond: x y z</code> -> evaluate as boolean x; if true return y, otherwise return z</li>
      </ul>
      All operators uses lazy evaluation. OR and AND expressions support 2 or more operators. COND expression only support 3. An example:
      <ul>
        <li><code>&lt;p tal:condition="and: ( exists:here/pets/dog ) ( not:here/pets/dog/badDog )"&gt;
                  Good Dog&lt;/p&gt;</code></li>
        <li><code>&lt;p tal:condition="or: isFridayNight isSaturday isSunday"&gt;
                  Yeah!&lt;/p&gt;</code></li>
        <li><code>&lt;p tal:content="cond: isFridayNight 'Yeah!' 'Oh!'"&gt;
                  What?&lt;/p&gt;</code></li>
      </ul>
    <p>
    
    <a name="tales.comparison">
    <h3>Comparison expressions</h3>
    <p>
      The 3 available comparison expressions are:
      <ul>
        <li><code>equals:</code> Checks if 2 or more integers are equals. If the values are not numbers, it checks if they are equals.</li>
        <li><code>greater:</code> Checks if a number is greater than another.</li>
        <li><code>lower:</code> Checks if a number is lower than another.</li>
      </ul>
      Some examples:
      <ul>
        <li><code>equals: here/assets here/liabilities anObject</code></li>
        <li><code>greater: 10 ( +: here/children here/pets )</code></li>
      </ul>
    </p>
    
    <a name="tales.other"></a>
    <h3>Other expressions</h3>
    <p>
      String expressions behave exactly as in ZPT. Python and Nocall expressions are not
      supported in JPT.
    </p>

    <a name="tal"></a>
    <h2>TAL Statements</h2>
    <p>
      All TAL statements behave almost exactly as in ZPT, except for <code>tal:no-call</code> which
      is not yet implemented (if you need it, holler). <code>tal:condition</code> and 
      <code>tal:omit-tag</code> must cast their expression to a boolean, which follows the rules
      described for <a href="#tales.not">Not expressions</a>.
    </p>

    <a name="tal.repeat"></a>
    <h3>tal:repeat</h3>
    <p>
      There are a few minor variations for <code>tal:repeat</code>. The repeat expression must 
      evaluate to an array, an <code>Iterator</code> or a <code>Collection</code>. If the 
      expression evaluates
      to an <code>Iterator</code> the repeat variable <code>length</code> is undefined. The 
      repeat variables <code>Letter</code> and <code>Roman</code> have been changed in JPT to
      <code>capitalLetter</code> and <code>capitalRoman</code>, to avoid confusion with Java
      case conventions.  
    </p>

    <a name="tal.tag"></a>
    <h3>tal:tag</h3>
    <p>
      This tag does not exist in ZPT. It allows to set an expression as the tag name ignoring 
      the tag name in the template, unless it evaluates to <code>null</code>. Some examples:<br/>
        <pre>
&lt;tal:block tal:define="condition true"&gt;
    &lt;p tal:tag="cond: condition 'div' 'span'"&gt;
        The tag is div.
    &lt;/p&gt;
&lt;/tal:block&gt;

&lt;tal:block&gt;
    &lt;p tal:tag="null"&gt;
        The tag is p.
    &lt;/p&gt;
&lt;/tal:block&gt;
        </pre>
    </p>
      
    <a name="i18n">
    <h2>I18n</h2>
    <p>
      I18n is implemented using <a href="https://code.google.com/p/gettext-commons/">gettext-commons</a>. There are a set of i18n related attributes you can use:
      <ul>
        <li><code>i18n:domain</code> Defines a list of I18n instances that will be used to recover i18n strings.</li>
        <li><code>i18n:define</code> Search the specified value into the available I18n instances and save the value to a variable.</li>       
        <li><code>i18n:content</code> It works as tal:content, but searching the specified value into the available I18n instances.</li>
        <li><code>i18n:replace</code> As tal:replace.</li>
        <li><code>i18n:attributes</code> As tal:attributes.</li>
        <li><code>i18n:on-error</code> As tal:on-error.</li>
      </ul>
      
      Some examples:
      <pre>
&lt;div i18n:domain="here/i18n1 here/i18n2"&gt;
    &lt;a i18n:attributes="title i18n_title"
       i18n:content="i18n_text"&gt;Text in current language&lt;/a&gt;
&lt;/div&gt;
      </pre>
      
      In this example we first set as available I18n instances the values from <code>here/i18n1</code> and <code>here/i18n2</code>. This means JPT will search the strings first in <code>here/i18n1</code>; if not found, it will search in <code>here/i18n2</code>. The title (<code>i18n_title</code>) and the content (<code>i18n_text</code>) of the a tag will be searched that way.
    </p>
    
    <a name="metal"></a>
    <h2>METAL</h2>
    <p>
      METAL statements behave exactly as in ZPT. The only difference, which is really a difference
      in Path expressions, is the means of finding another template which contains macros. Since,
      there is no Zope tree in which to locate templates, templates must be resolved via a URI.  
      The predefined variable, <code>resolver</code>, holds a reference to an instance of 
      <code>Resolver</code> which can be used to resolve references to external templates.
     </p>
     <p>
       The <code>Resolver</code> class contains these methods:
       <ul>
         <li>getPageTemplate( String uri )</li>
         <li>getResource( String uri )</li>
         <li>getScript( String uri )</li>
       </ul>
       The <code>getPageTemplate</code> method returns a <code>PageTemplate</code> instance which can then
       be used for macro processing. <code>getScript</code> returns 
       <a href="#tales.java.scripts">script</a> that is then executed.  
       <code>getResource</code> is there in case anyone needs a more generic resource
       finding method and returns a <code>URL</code>. If the URI passed to these methods is relative
       it will be resolved relative to the URI of the current template.  
     </p>
     <p>
       For example:<br>
       <pre>
&lt;html metal:use-macro="resolver/getPageTemplate( '../base.jpt' )/macros/page"&gt;
  &lt;div metal:fill-slot="content"&gt;
    This is the content for my web page.
  &lt;/div&gt;
&lt;/html&gt;
       </pre>
     </p>

    <a name="moreExamples">
    <h2>More examples</h2>
    <p>
      Please, take a look to test files in <code>test/resources</code> to view more JPT examples. The files ending by 
      <code>'.jpt'</code> are the templates; the files ending by <code>'-1P.html'</code> are the expected test results 
      for 1 phase implementation; the files ending by <code>'-2P.html'</code> are the expected test results for 2 phases 
      implementation.

    <a name="tales.context">
    <h2>JPT context</h2>
    <p>
      You can use some methods of the JPTContext class to configure some options (see javadocs to view complete list of methods):
      <ul>
        <li><code>void setParseHTMLFragments( boolean value )</code> Allow or deny parsing of HTML fragments. Default is true.</li>
        <li><code>void setCacheOn( boolean value )</code> Set the cache on or off. Default is true.</li>
        <li><code>void setUseHtmlReader( boolean value )</code> Allow or deny using of HTMLReader when XMLReader fails. Default is false.</li>
        <li><code>void setJavaExpressionsOn( boolean value )</code> Allow or deny using of java expressions (for security reasons, mainly). Default is true.</li>
        <li><code>void setTranslator( Translator translator )</code> Set the translator class. Default is an instance of an included production implementation.</li>
        <li><code>void setEmptyTags( Set&lt;String&gt; emptyTags )</code> Set a new set of allowed empty tags. Default are area, base, br, col, hr, img, input, link, meta and param.</li>
        <li><code>void setTemplateCache( TemplateCache templateCache )</code> Define an instance of a class that implements the TemplateCache interface to support caching. Default is an instance of DefaultTemplateCache (not for production use, only for testing purposes). Only available for onePhaseImpl version.</li>
        <li><code>void setJPTDocumentCache( JPTDocumentCache jptDocumentCache )</code> Define an instance of a class that implements the JPTDocumentCache interface to support caching. Default is an instance of DefaultJPTDocumentCache (not for production use, only for testing purposes). Only available for twoPhasesImpl version.</li>
        <li><code>void initEvaluators( )</code> Remove all evaluators from context. Don't forget to register evaluators! See <a href="#evaluators">Evaluators</a> for details.</li>
        <li><code>void registerEvaluator( Evaluator evaluator, String extension )</code> Register an evaluator for a file extension. See <a href="#evaluators">Evaluators</a> for details.</li>
        <li><code>void registerEvaluator( Evaluator evaluator, List&lt;String&gt; extensions )</code> Register an evaluator for a list of file extensions. See <a href="#evaluators">Evaluators</a> for details.</li>
        <li><code>void setEvaluators( Map<String, Evaluator> evaluators )</code> Set the list of evaluators. See <a href="#evaluators">Evaluators</a> for details.</li>
        <li><code>void setExpressionEvaluator( Evaluator expressionEvaluator )</code> Set the evaluator for script expressions. By default it is BeanShell, Groovy is also available. See <a href="tales.java">Java expressions</a> for details.</li>
        <li><code>void setCharToReplaceAmpersand( char charToReplaceAmpersand )</code>. Probably you use ampersands in java expressions (as the AND operator). Due to XML restrictions all occurences of this character you may replace them by another one (the default is '_'). You can customize this character using this method.</li>
      </ul>
    </p>
      
     <a name="invocation"></a>
     <h2>Invoking Page Templates</h2>
     <p>
       There are 2 available implementations of JPT. The first one is PageTemplateImpl, that makes all the job in one phase, reading the JPT file and generating the output simultaneously. The second one is TwoPhasesPageTemplateImpl, that divides the job in two phases:
       <ul>
         <li>A first phase reading the JPT and generating a java representation.</li>
         <li>A second phase reading the java representation and generating the real output.</li>
       </ul>
       It is recommended to use the two phases implementation, the performance is better and new enhancements could only be available in that one.
     </p>
     <p>
       But, how can we use JPT? The <code>context</code> may be any Java object.  This is the same object referred to by <code>here</code> in path expressions.  The <code>dictionary</code> is optional and may be used to define variables for use by the template.
     </p>
     <p>
       An example of invoking a PageTemplate from a Servlet:
     <pre>
public class MyServlet extends HttpServlet {
    public void service( HttpServletRequest request, HttpServletResponse response )
        throws ServletException, IOException
    {
        // Some business logic here. . . .
        User user = . . . 
        Record record = . . .

        // Response to user
        try {
        // Find and instantiate template, located in the record directory
            // under our web application root.
            URL templateURL = getServletContext().getResource( "record/showrecord.jpt" );
            PageTemplate template = new TwoPhasesPageTemplateImpl( templateURL );

            // Initialize some variables to be used by the template
            Map dictionary = new HashMap();
            dictionary.put( "request", request );
            dictionary.put( "user", user );

            // Output response
            OutputStream output = response.getOutputStream();
    	    response.setContentType( "text/html" );
            template.process( output, record, dictionary );
            output.close();
            
        } catch( PageTemplateException e ) {
            // Oh no!
            throw new ServletException( e );
        }
    }
}
    </pre>
    </p>
  </body>
</html>
     
